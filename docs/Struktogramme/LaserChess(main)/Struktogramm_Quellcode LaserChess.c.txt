int gfxmain(int argc, char* argv[], const char *ApplicationPath)
{
    EXE-Pfad uebergeben, damit global verwendbar
    Structarray für die Figuren definieren
    Begrüssungstitel und Befehlseingaben ausgeben
    while ( Endlosschlaufe )
    {
        Map löschen
        Intro-Sound abspielen
        do{
            Spielmodus einlesen
        }while ( ungültige Eingabe );
        Intro-Sound beenden
        if ( Spiel abgebrochen )
        {
            return Spiel beenden;
        }
        else
        {
            if ( Token für EasterEgg1 eingegeben )
            {
                Easter egg 1 wird ausgeführt
                continue;
            }
            else
            {
                if ( Token für EasterEgg2 eingegeben )
                {
                    Eater egg 2 wird ausgeführt
                    continue;
                }
                else
                {
                    if ( Token für EasterEgg3 eingegeben )
                    {
                        Eater egg 3 wird ausgeführt
                        continue;
                    }
                }
            }
        }
         Figuren erstellen und initialisieren
         Spiel initialisieren
        if ( erfogreich initialisiert )
        {
            Spiel starten
        }
    }
    return Spiel beenden;
}

void argument_handler(int argn, char* args[], pawn *figure)
{    
    //Standardwerte der Variablen
    FIELD_SIZE = 100;
    //Ende der Startwerte
    
    //Argument 0 = AppPath (Standardmaessig immer so)
    //Argument 1 = Dateipfad (Falls eine Datei mit LaserChess geoffnet wird)
    
    //Falls es nicht mehr als ein Argument (AppPath) gibt, abbrechen
    if ( nicht mehr als ein Argument übergeben )
    {
        return abbrechen;
    }
    //Ist Argument 1 ein Pfad? (Ist 2. Buchstabe ':', wie z.B. in "C:Map1.txt"?)
    if ( ist Argument 1 ein Pfad' )
    {
        Anzeige, dass es geöffnet wird
        Figuren erstellen und initialisieren
        Spiel initialisierne
        if ( Initialisieren erfolgreich )
        {
            Spiel starten
        }
        //Wenn im Eclipse gestartet (Argument 1 ist %*)
    }
    else
    {
        if ( Program aus dem Eclipse gestartet )
        {
            Anzeige: aus Eclipse geöffnet
            Sonstige Argumente behandeln
        }
        else
        {
            Buffer fuer Werte erstellen
            for ( alle Argumente )
            {
                /*Vorlage fuer Variablen (Bsp mit Field_size)*/
                //Bekannte Variable?
                if ( Argument ist "-Field_size") )
                {
                    //Wert (naechstes Argument) vorhanden und keine variable?
                    if ( nächstes Argument vorhanden UND es ist keine Variable )
                    {
                        Falls Argument eine Zahl ist, wird diese hier in buffer kopiert
                        //(Werte groesser als (2^32 - 1) geben einen Ueberlauf, 2^32 gibt also wieder 0)
                        sscanf(args[i+1], "%u", &buffer);
                        
                        //Pruefen ob Argument eine gueltige Zahl war
                        //(wenn nicht, dann hat buffer noch startwert 0)
                        if ( gültige Zahl im Buffer )
                        {
                            //Feldgroesse maximal 200 und minimal 20
                            if ( Buffer grösser als Maximumgrösse )
                            {
                                Buffer auf maximum begrenzen
                            }
                            else
                            {
                                if ( Buffer kleiner als Minimumgrösse )
                                {
                                    Buffer auf minimum begrenzen
                                }
                            }
                            Feldgrösse auf Bufferwert festlegen
                            Ausgabe: Feldgrösse ist ....
                        }
                        else
                        {
                            Ausgabe: Ungültige Zahl im Buffer
                        }
                        Naechstes Argument ueberspringen, da wir das soeben als Wert gelesen haben (oder versucht)
                    }
                    else
                    {
                        Ausgabe: Parameter nicht gefunden;
                    }
                }
                else
                {
                    Ausgabe: Unbekanntes Argument
                }
            }
        }
    }
    printf("\n\n");
}

enum Spielmodus menu(void)
{
        Eingabebuffer definieren
        Ausgabe: Befehl eingeben
        Befehl als String einlesen
        if ( erste Stelle im String eine Zahl) )
        {
            String in Zahlenwert umrechnen
        }
        switch ( Eingabe unterscheiden )
        {
        case 1 eingegeben :
            Normaler Spielmodus
            return Rückgabe Normaler Modus;
        case 2 eingegeben :
            Figuren Manuell platzieren
            return Rückgabe Platzier Modus;
        case 3 eingegeben :
            Aufstellung aus Datei laden
            return Rückgabe Datei-Lese Modus;
        case 4 eingegeben :
            if ( Token für EasterEgg1 eingegeben )
            {
                EasterEgg1 wählen
                return Rückgabe EasterEgg1;
            }
            else
            {
                Sound starten bzw. stoppen
                return Ungültiger Rückgabewert, damit die Funktion 
                       nochmals aufgerufne wird;
            }
        case 5 eingegeben :
            if ( Token für EasterEgg2 eingegeben )
            {
                EasterEgg 2 wählen
                return Rückgabe EasterEgg2;
            }
            else
            {
                if ( Token für EasterEgg3 eingegeben )
                {
                    EasterEgg3 wählen
                    return Rückgabe EasterEgg3;
                }
                else
                {
                    Programm beenden
                    return Beenden zurückgeben;
                }
            }
        default:
            Anzeige: Ungültige Eingabe
            return Rückgabe Ungültige Eingabe;
        }
}

void create_figures(pawn *figure)
{
    Initialisierung aller Spielfiguren
}
int set_figure_positions(pawn *figure)
{
    Zwei Position Structs, wo die letdzten zwei Mousecklicks gespeichert werden definieren
    Struct wo Mouseevents gespeicert werden definieren
    while ( bis alle Figuren gesetzt sind )
    {
        switch ( Status )
        {
        case Figur setzen :
            Mausklick einlesen
            if ( Innerhalb der Map und nicht auf eine Andere Figur geklickt )
            {
                Mapkoordinaten in der Figur speichern
                Figur auf Map setzen
                Figur zeichnen
                Rotationsfokus drüber, damit Rotationsmodus ersichtlich
                Status zu Rotieren wechseln
                if ( i+1 < ANZ_FIGURES )
                {
                    if ( figure[(i+1)/2].TYPE == KING )
                    {
                        printf("\r                     \rNext Figure: King");
                    }
                    if ( figure[(i+1)/2].TYPE == MIRROR )
                    {
                        printf("\r                     \rNext Figure: Mirror");
                    }
                    if ( figure[(i+1)/2].TYPE == SPLITTER )
                    {
                        printf("\r                     \rNext Figure: Splitter");
                    }
                    if ( figure[(i+1)/2].TYPE == WALL )
                    {
                        printf("\r                     \rNext Figure: Wall");
                    }
                    if ( figure[(i+1)/2].TYPE == CANNON )
                    {
                        printf("\r                     \rNext Figure: Cannon");
                    }
                }
                STATE = ROTATE;
            }
            break;
        case ROTATE :
            // Wenn 2. Mal auf die Figur gedrückt wird, ist der Zug beendet, wenn am mouserad gedreht wird, wird die Figur gedreht
            	MouseEvent = GetMouseEvent();	// Holt Mouseevent
            if ( MouseEvent.ButtonState & W_BUTTON_PRESSED )
            {
                mouse_pos.x = MouseEvent.MousePosX;
                mouse_pos.y = MouseEvent.MousePosY;
                mouse_pos = pixel_to_map(mouse_pos);
                // Wenn ein 2. Mal gültig gecklickt
                 wird, figur auf Maparray speichern, Player Wechseln
                if ( is_inside_map(mouse_pos) )
                {
                    draw_figure(map[figure_pos.x][figure_pos.y]); 
                    // Figur nochmals zeichnen, da Rotationsfokus 
                    noch darüber gezeichnet ist
                    PLAYER = !PLAYER;	// Player toggeln
                    STATE = READ_POS;
                    i++;				// Nächste Figur zum Setzen
                }
            }
            else
            {
                // Man kann so lange drehen, bis ein 2. mal geklickt wird
                if ( MouseEvent.ButtonState & W_MOUSE_WHEEL_CHANGE )
                {
                    if ( MouseEvent.MouseWheelDelta > 0 )
                    {
                        // Figur solange drehen bis Taste gedrückt
                        ROTATE_LEFT(map[figure_pos.x][figure_pos.y]->DIR);
                    }
                    else
                    {
                        ROTATE_RIGHT(map[figure_pos.x][figure_pos.y]->DIR);
                    }
                    // Zeichnet die Figur neu, wenn sie gedreht wurde
                    draw_figure(map[figure_pos.x][figure_pos.y]);
                    draw_rot_focus(figure_pos);
                }
            }
            break;
        }
        if ( IsKeyPressReady() && (GetKeyPress() == W_KEY_CLOSE_WINDOW) )
        {
            //Fenster schliessen geklickt
            // KeyPress Buffer löschen
            while ( IsKeyPressReady() )
            {
                GetKeyPress();
            }
            printf("\r                     \r"); //Ganze Zeile wieder loeschen
            destroy_images(); //Geladene Images aus Speicher loeschen
            CloseGraphic(); //Grafikfenster schliessen
            return -1;
        }
    }
    printf("\r                     \r"); //Ganze Zeile wieder loeschen
    return 0;
}

